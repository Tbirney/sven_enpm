{"func_name": "_get_numpy_tools", "func_src_before": "def _get_numpy_tools(filename):\n    filepath = pathlib.Path('tools', filename)\n    spec = importlib.util.spec_from_file_location(filename.stem, filepath)\n    module = importlib.util.module_from_spec(spec)\n    spec.loader.exec_module(module)\n    return module", "func_src_after": "def assert_produces_warning(\n    expected_warning: type[Warning] | bool | tuple[type[Warning], ...] | None = Warning,\n    filter_level: Literal[\n        \"error\", \"ignore\", \"always\", \"default\", \"module\", \"once\"\n    ] = \"always\",\n    check_stacklevel: bool = True,\n    raise_on_extra_warnings: bool = True,\n    match: str | None = None,\n) -> Generator[list[warnings.WarningMessage], None, None]:\n    \"\"\"\n    Context manager for running code expected to either raise a specific warning,\n    multiple specific warnings, or not raise any warnings. Verifies that the code\n    raises the expected warning(s), and that it does not raise any other unexpected\n    warnings. It is basically a wrapper around ``warnings.catch_warnings``.\n\n    Parameters\n    ----------\n    expected_warning : {Warning, False, tuple[Warning, ...], None}, default Warning\n        The type of Exception raised. ``exception.Warning`` is the base\n        class for all warnings. To raise multiple types of exceptions,\n        pass them as a tuple. To check that no warning is returned,\n        specify ``False`` or ``None``.\n    filter_level : str or None, default \"always\"\n        Specifies whether warnings are ignored, displayed, or turned\n        into errors.\n        Valid values are:\n\n        * \"error\" - turns matching warnings into exceptions\n        * \"ignore\" - discard the warning\n        * \"always\" - always emit a warning\n        * \"default\" - print the warning the first time it is generated\n          from each location\n        * \"module\" - print the warning the first time it is generated\n          from each module\n        * \"once\" - print the warning the first time it is generated\n\n    check_stacklevel : bool, default True\n        If True, displays the line that called the function containing\n        the warning to show were the function is called. Otherwise, the\n        line that implements the function is displayed.\n    raise_on_extra_warnings : bool, default True\n        Whether extra warnings not of the type `expected_warning` should\n        cause the test to fail.\n    match : str, optional\n        Match warning message.\n\n    Examples\n    --------\n    >>> import warnings\n    >>> with assert_produces_warning():\n    ...     warnings.warn(UserWarning())\n    ...\n    >>> with assert_produces_warning(False):\n    ...     warnings.warn(RuntimeWarning())\n    ...\n    Traceback (most recent call last):\n        ...\n    AssertionError: Caused unexpected warning(s): ['RuntimeWarning'].\n    >>> with assert_produces_warning(UserWarning):\n    ...     warnings.warn(RuntimeWarning())\n    Traceback (most recent call last):\n        ...\n    AssertionError: Did not see expected warning of class 'UserWarning'.\n\n    ..warn:: This is *not* thread-safe.\n    \"\"\"\n    __tracebackhide__ = True\n\n    with warnings.catch_warnings(record=True) as w:\n        warnings.simplefilter(filter_level)\n        try:\n            yield w\n        finally:\n            if expected_warning:\n                expected_warning = cast(type[Warning], expected_warning)\n                _assert_caught_expected_warning(\n                    caught_warnings=w,\n                    expected_warning=expected_warning,\n                    match=match,\n                    check_stacklevel=check_stacklevel,\n                )\n            if raise_on_extra_warnings:\n                _assert_caught_no_extra_warnings(\n                    caught_warnings=w,\n                    expected_warning=expected_warning,\n                )", "line_changes": {"deleted": [{"line_no": 2, "char_start": 32, "char_end": 78, "line": "    filepath = pathlib.Path('tools', filename)"}, {"line_no": 4, "char_start": 154, "char_end": 204, "line": "    module = importlib.util.module_from_spec(spec)"}, {"line_no": 5, "char_start": 205, "char_end": 240, "line": "    spec.loader.exec_module(module)"}, {"line_no": 6, "char_start": 241, "char_end": 258, "line": "    return module"}], "added": [{"line_no": 2, "char_start": 29, "char_end": 117, "line": "    expected_warning: type[Warning] | bool | tuple[type[Warning], ...] | None = Warning,"}, {"line_no": 3, "char_start": 118, "char_end": 144, "line": "    filter_level: Literal["}, {"line_no": 4, "char_start": 145, "char_end": 209, "line": "        \"error\", \"ignore\", \"always\", \"default\", \"module\", \"once\""}, {"line_no": 5, "char_start": 210, "char_end": 227, "line": "    ] = \"always\","}, {"line_no": 6, "char_start": 228, "char_end": 262, "line": "    check_stacklevel: bool = True,"}, {"line_no": 7, "char_start": 263, "char_end": 304, "line": "    raise_on_extra_warnings: bool = True,"}, {"line_no": 8, "char_start": 305, "char_end": 334, "line": "    match: str | None = None,"}, {"line_no": 9, "char_start": 335, "char_end": 393, "line": ") -> Generator[list[warnings.WarningMessage], None, None]:"}, {"line_no": 10, "char_start": 394, "char_end": 401, "line": "    \"\"\""}, {"line_no": 11, "char_start": 402, "char_end": 483, "line": "    Context manager for running code expected to either raise a specific warning,"}, {"line_no": 12, "char_start": 484, "char_end": 565, "line": "    multiple specific warnings, or not raise any warnings. Verifies that the code"}, {"line_no": 13, "char_start": 566, "char_end": 649, "line": "    raises the expected warning(s), and that it does not raise any other unexpected"}, {"line_no": 14, "char_start": 650, "char_end": 725, "line": "    warnings. It is basically a wrapper around ``warnings.catch_warnings``."}]}, "char_changes": {"deleted": [{"char_start": 4, "char_end": 78, "chars": "_get_numpy_tools(filename):\n    filepath = pathlib.Path('tools', filename)"}, {"char_start": 83, "char_end": 84, "chars": "s"}, {"char_start": 87, "char_end": 258, "chars": " = importlib.util.spec_from_file_location(filename.stem, filepath)\n    module = importlib.util.module_from_spec(spec)\n    spec.loader.exec_module(module)\n    return module"}], "added": [{"char_start": 4, "char_end": 3477, "chars": "assert_produces_warning(\n    expected_warning: type[Warning] | bool | tuple[type[Warning], ...] | None = Warning,\n    filter_level: Literal[\n        \"error\", \"ignore\", \"always\", \"default\", \"module\", \"once\"\n    ] = \"always\",\n    check_stacklevel: bool = True,\n    raise_on_extra_warnings: bool = True,\n    match: str | None = None,\n) -> Generator[list[warnings.WarningMessage], None, None]:\n    \"\"\"\n    Context manager for running code expected to either raise a specific warning,\n    multiple specific warnings, or not raise any warnings. Verifies that the code\n    raises the expected warning(s), and that it does not raise any other unexpected\n    warnings. It is basically a wrapper around ``warnings.catch_warnings``.\n\n    Parameters\n    ----------\n    expected_warning : {Warning, False, tuple[Warning, ...], None}, default Warning\n        The type of Exception raised. ``exception.Warning`` is the base\n        class for all warnings. To raise multiple types of exceptions,\n        pass them as a tuple. To check that no warning is returned,\n        specify ``False`` or ``None``.\n    filter_level : str or None, default \"always\"\n        Specifies whether warnings are ignored, displayed, or turned\n        into errors.\n        Valid values are:\n\n        * \"error\" - turns matching warnings into exceptions\n        * \"ignore\" - discard the warning\n        * \"always\" - always emit a warning\n        * \"default\" - print the warning the first time it is generated\n          from each location\n        * \"module\" - print the warning the first time it is generated\n          from each module\n        * \"once\" - print the warning the first time it is generated\n\n    check_stacklevel : bool, default True\n        If True, displays the line that called the function containing\n        the warning to show were the function is called. Otherwise, the\n        line that implements the function is displayed.\n    raise_on_extra_warnings : bool, default True\n        Whether extra warnings not of the type `expected_warning` should\n        cause the test to fail.\n    match : str, optional\n        Match warning message.\n\n    Examples\n    --------\n    >>> import warnings\n    >>> with assert_produces_warning():\n    ...     warnings.warn(UserWarning())\n    ...\n    >>> with assert_produces_warning(False):\n    ...     warnings.warn(RuntimeWarning())\n    ...\n    Traceback (most recent call last):\n        ...\n    AssertionError: Caused unexpected warning(s): ['RuntimeWarning'].\n    >>> with assert_produces_warning(UserWarning):\n    ...     warnings.warn(RuntimeWarning())\n    Traceback (most recent call last):\n        ...\n    AssertionError: Did not see expected warning of class 'UserWarning'.\n\n    ..warn:: This is *not* thread-safe.\n    \"\"\"\n    __tracebackhide__ = True\n\n    with warnings.catch_warnings(record=True) as w:\n        warnings.simplefilter(filter_level)\n        try:\n            yield w\n        finally:\n            if expected_warning:\n                expected_warning = cast(type[Warning], expected_warning)\n                _assert_caught_expected_warning(\n                    caught_warnings=w,\n                    expected_warning=expected_warning,\n                    match=match,\n                    check_stacklevel=check_stacklevel,\n                )\n            if raise_on_extra_warnings:\n                _assert_caught_no_extra_warnings(\n                    caught_warnings=w,\n                    expected_warning=expected_warning,\n                )"}]}}
{"func_name": "changelog", "func_src_before": "def changelog(ctx, token, revision_range):\n    \"\"\"\ud83d\udc69 Get change log for provided revision range\n\n    \\b\n    Example:\n\n    \\b\n    $ spin authors -t $GH_TOKEN --revision-range v1.25.0..v1.26.0\n    \"\"\"\n    try:\n        from github.GithubException import GithubException\n        from git.exc import GitError\n        changelog = _get_numpy_tools(pathlib.Path('changelog.py'))\n    except ModuleNotFoundError as e:\n        raise click.ClickException(\n            f\"{e.msg}. Install the missing packages to use this command.\"\n        )\n    click.secho(\n        f\"Generating change log for range {revision_range}\",\n        bold=True, fg=\"bright_green\",\n    )\n    try:\n        changelog.main(token, revision_range)\n    except GithubException as e:\n        raise click.ClickException(\n            f\"GithubException raised with status: {e.status} \"\n            f\"and message: {e.data['message']}\"\n        )\n    except GitError as e:\n        raise click.ClickException(\n            f\"Git error in command `{' '.join(e.command)}` \"\n            f\"with error message: {e.stderr}\"\n        )", "func_src_after": "def maybe_produces_warning(warning: type[Warning], condition: bool, **kwargs):\n    \"\"\"\n    Return a context manager that possibly checks a warning based on the condition\n    \"\"\"\n    if condition:\n        return assert_produces_warning(warning, **kwargs)\n    else:\n        return nullcontext()", "line_changes": {"deleted": [{"line_no": 2, "char_start": 43, "char_end": 94, "line": "    \"\"\"\ud83d\udc69 Get change log for provided revision range"}], "added": [{"line_no": 2, "char_start": 79, "char_end": 86, "line": "    \"\"\""}, {"line_no": 4, "char_start": 170, "char_end": 177, "line": "    \"\"\""}, {"line_no": 5, "char_start": 178, "char_end": 195, "line": "    if condition:"}, {"line_no": 6, "char_start": 196, "char_end": 253, "line": "        return assert_produces_warning(warning, **kwargs)"}, {"line_no": 7, "char_start": 254, "char_end": 263, "line": "    else:"}, {"line_no": 8, "char_start": 264, "char_end": 292, "line": "        return nullcontext()"}]}, "char_changes": {"deleted": [{"char_start": 4, "char_end": 1071, "chars": "changelog(ctx, token, revision_range):\n    \"\"\"\ud83d\udc69 Get change log for provided revision range\n\n    \\b\n    Example:\n\n    \\b\n    $ spin authors -t $GH_TOKEN --revision-range v1.25.0..v1.26.0\n    \"\"\"\n    try:\n        from github.GithubException import GithubException\n        from git.exc import GitError\n        changelog = _get_numpy_tools(pathlib.Path('changelog.py'))\n    except ModuleNotFoundError as e:\n        raise click.ClickException(\n            f\"{e.msg}. Install the missing packages to use this command.\"\n        )\n    click.secho(\n        f\"Generating change log for range {revision_range}\",\n        bold=True, fg=\"bright_green\",\n    )\n    try:\n        changelog.main(token, revision_range)\n    except GithubException as e:\n        raise click.ClickException(\n            f\"GithubException raised with status: {e.status} \"\n            f\"and message: {e.data['message']}\"\n        )\n    except GitError as e:\n        raise click.ClickException(\n            f\"Git error in command `{' '.join(e.command)}` \"\n            f\"with error message: {e.stderr}\"\n        "}], "added": [{"char_start": 4, "char_end": 155, "chars": "maybe_produces_warning(warning: type[Warning], condition: bool, **kwargs):\n    \"\"\"\n    Return a context manager that possibly checks a warning based on"}, {"char_start": 158, "char_end": 159, "chars": "e"}, {"char_start": 162, "char_end": 291, "chars": "ndition\n    \"\"\"\n    if condition:\n        return assert_produces_warning(warning, **kwargs)\n    else:\n        return nullcontext("}]}}
{"func_name": "build", "func_src_before": "def build(ctx, meson_args, with_scipy_openblas, jobs=None, clean=False, verbose=False, quiet=False):\n    \"\"\"\ud83d\udd27 Build package with Meson/ninja and install\n\n    MESON_ARGS are passed through e.g.:\n\n    spin build -- -Dpkg_config_path=/lib64/pkgconfig\n\n    The package is installed to build-install\n\n    By default builds for release, to be able to use a debugger set CFLAGS\n    appropriately. For example, for linux use\n\n    CFLAGS=\"-O0 -g\" spin build\n    \"\"\"\n    # XXX keep in sync with upstream build\n    if with_scipy_openblas:\n        _config_openblas(with_scipy_openblas)\n    ctx.params.pop(\"with_scipy_openblas\", None)\n    ctx.forward(meson.build)", "func_src_after": "def _assert_caught_expected_warning(\n    *,\n    caught_warnings: Sequence[warnings.WarningMessage],\n    expected_warning: type[Warning],\n    match: str | None,\n    check_stacklevel: bool,\n) -> None:\n    \"\"\"Assert that there was the expected warning among the caught warnings.\"\"\"\n    saw_warning = False\n    matched_message = False\n    unmatched_messages = []\n\n    for actual_warning in caught_warnings:\n        if issubclass(actual_warning.category, expected_warning):\n            saw_warning = True\n\n            if check_stacklevel:\n                _assert_raised_with_correct_stacklevel(actual_warning)\n\n            if match is not None:\n                if re.search(match, str(actual_warning.message)):\n                    matched_message = True\n                else:\n                    unmatched_messages.append(actual_warning.message)\n\n    if not saw_warning:\n        raise AssertionError(\n            f\"Did not see expected warning of class \"\n            f\"{repr(expected_warning.__name__)}\"\n        )\n\n    if match and not matched_message:\n        raise AssertionError(\n            f\"Did not see warning {repr(expected_warning.__name__)} \"\n            f\"matching '{match}'. The emitted warning messages are \"\n            f\"{unmatched_messages}\"\n        )", "line_changes": {"deleted": [{"line_no": 2, "char_start": 101, "char_end": 152, "line": "    \"\"\"\ud83d\udd27 Build package with Meson/ninja and install"}], "added": [{"line_no": 2, "char_start": 37, "char_end": 43, "line": "    *,"}, {"line_no": 3, "char_start": 44, "char_end": 99, "line": "    caught_warnings: Sequence[warnings.WarningMessage],"}, {"line_no": 4, "char_start": 100, "char_end": 136, "line": "    expected_warning: type[Warning],"}, {"line_no": 5, "char_start": 137, "char_end": 159, "line": "    match: str | None,"}, {"line_no": 6, "char_start": 160, "char_end": 187, "line": "    check_stacklevel: bool,"}, {"line_no": 7, "char_start": 188, "char_end": 198, "line": ") -> None:"}, {"line_no": 8, "char_start": 199, "char_end": 278, "line": "    \"\"\"Assert that there was the expected warning among the caught warnings.\"\"\""}, {"line_no": 9, "char_start": 279, "char_end": 302, "line": "    saw_warning = False"}, {"line_no": 10, "char_start": 303, "char_end": 330, "line": "    matched_message = False"}, {"line_no": 11, "char_start": 331, "char_end": 358, "line": "    unmatched_messages = []"}, {"line_no": 14, "char_start": 403, "char_end": 468, "line": "        if issubclass(actual_warning.category, expected_warning):"}, {"line_no": 15, "char_start": 469, "char_end": 499, "line": "            saw_warning = True"}]}, "char_changes": {"deleted": [{"char_start": 4, "char_end": 649, "chars": "build(ctx, meson_args, with_scipy_openblas, jobs=None, clean=False, verbose=False, quiet=False):\n    \"\"\"\ud83d\udd27 Build package with Meson/ninja and install\n\n    MESON_ARGS are passed through e.g.:\n\n    spin build -- -Dpkg_config_path=/lib64/pkgconfig\n\n    The package is installed to build-install\n\n    By default builds for release, to be able to use a debugger set CFLAGS\n    appropriately. For example, for linux use\n\n    CFLAGS=\"-O0 -g\" spin build\n    \"\"\"\n    # XXX keep in sync with upstream build\n    if with_scipy_openblas:\n        _config_openblas(with_scipy_openblas)\n    ctx.params.pop(\"with_scipy_openblas\", None)\n    ctx.forward(meson.build"}], "added": [{"char_start": 4, "char_end": 401, "chars": "_assert_caught_expected_warning(\n    *,\n    caught_warnings: Sequence[warnings.WarningMessage],\n    expected_warning: type[Warning],\n    match: str | None,\n    check_stacklevel: bool,\n) -> None:\n    \"\"\"Assert that there was the expected warning among the caught warnings.\"\"\"\n    saw_warning = False\n    matched_message = False\n    unmatched_messages = []\n\n    for actual_warning in caught_warnings"}, {"char_start": 403, "char_end": 404, "chars": " "}, {"char_start": 408, "char_end": 1261, "chars": "   if issubclass(actual_warning.category, expected_warning):\n            saw_warning = True\n\n            if check_stacklevel:\n                _assert_raised_with_correct_stacklevel(actual_warning)\n\n            if match is not None:\n                if re.search(match, str(actual_warning.message)):\n                    matched_message = True\n                else:\n                    unmatched_messages.append(actual_warning.message)\n\n    if not saw_warning:\n        raise AssertionError(\n            f\"Did not see expected warning of class \"\n            f\"{repr(expected_warning.__name__)}\"\n        )\n\n    if match and not matched_message:\n        raise AssertionError(\n            f\"Did not see warning {repr(expected_warning.__name__)} \"\n            f\"matching '{match}'. The emitted warning messages are \"\n            f\"{unmatched_messages}\"\n        "}]}}
{"func_name": "docs", "func_src_before": "def docs(ctx, sphinx_target, clean, first_build, jobs):\n    \"\"\"\ud83d\udcd6 Build Sphinx documentation\n\n    By default, SPHINXOPTS=\"-W\", raising errors on warnings.\n    To build without raising on warnings:\n\n      SPHINXOPTS=\"\" spin docs\n\n    To list all Sphinx targets:\n\n      spin docs targets\n\n    To build another Sphinx target:\n\n      spin docs TARGET\n\n    E.g., to build a zipfile of the html docs for distribution:\n\n      spin docs dist\n\n    \"\"\"\n    meson.docs.ignore_unknown_options = True\n    ctx.forward(meson.docs)", "func_src_after": "def _assert_caught_no_extra_warnings(\n    *,\n    caught_warnings: Sequence[warnings.WarningMessage],\n    expected_warning: type[Warning] | bool | tuple[type[Warning], ...] | None,\n) -> None:\n    \"\"\"Assert that no extra warnings apart from the expected ones are caught.\"\"\"\n    extra_warnings = []\n\n    for actual_warning in caught_warnings:\n        if _is_unexpected_warning(actual_warning, expected_warning):\n            # GH#38630 pytest.filterwarnings does not suppress these.\n            if actual_warning.category == ResourceWarning:\n                # GH 44732: Don't make the CI flaky by filtering SSL-related\n                # ResourceWarning from dependencies\n                if \"unclosed <ssl.SSLSocket\" in str(actual_warning.message):\n                    continue\n                # GH 44844: Matplotlib leaves font files open during the entire process\n                # upon import. Don't make CI flaky if ResourceWarning raised\n                # due to these open files.\n                if any(\"matplotlib\" in mod for mod in sys.modules):\n                    continue\n            if PY311 and actual_warning.category == EncodingWarning:\n                # EncodingWarnings are checked in the CI\n                # pyproject.toml errors on EncodingWarnings in pandas\n                # Ignore EncodingWarnings from other libraries\n                continue\n            extra_warnings.append(\n                (\n                    actual_warning.category.__name__,\n                    actual_warning.message,\n                    actual_warning.filename,\n                    actual_warning.lineno,\n                )\n            )\n\n    if extra_warnings:\n        raise AssertionError(f\"Caused unexpected warning(s): {repr(extra_warnings)}\")", "line_changes": {"deleted": [{"line_no": 2, "char_start": 56, "char_end": 91, "line": "    \"\"\"\ud83d\udcd6 Build Sphinx documentation"}], "added": [{"line_no": 2, "char_start": 38, "char_end": 44, "line": "    *,"}, {"line_no": 3, "char_start": 45, "char_end": 100, "line": "    caught_warnings: Sequence[warnings.WarningMessage],"}, {"line_no": 4, "char_start": 101, "char_end": 179, "line": "    expected_warning: type[Warning] | bool | tuple[type[Warning], ...] | None,"}, {"line_no": 5, "char_start": 180, "char_end": 190, "line": ") -> None:"}, {"line_no": 6, "char_start": 191, "char_end": 271, "line": "    \"\"\"Assert that no extra warnings apart from the expected ones are caught.\"\"\""}, {"line_no": 7, "char_start": 272, "char_end": 295, "line": "    extra_warnings = []"}, {"line_no": 11, "char_start": 409, "char_end": 478, "line": "            # GH#38630 pytest.filterwarnings does not suppress these."}, {"line_no": 12, "char_start": 479, "char_end": 537, "line": "            if actual_warning.category == ResourceWarning:"}, {"line_no": 13, "char_start": 538, "char_end": 614, "line": "                # GH 44732: Don't make the CI flaky by filtering SSL-related"}, {"line_no": 14, "char_start": 615, "char_end": 666, "line": "                # ResourceWarning from dependencies"}, {"line_no": 15, "char_start": 667, "char_end": 743, "line": "                if \"unclosed <ssl.SSLSocket\" in str(actual_warning.message):"}, {"line_no": 16, "char_start": 744, "char_end": 772, "line": "                    continue"}, {"line_no": 17, "char_start": 773, "char_end": 860, "line": "                # GH 44844: Matplotlib leaves font files open during the entire process"}, {"line_no": 18, "char_start": 861, "char_end": 937, "line": "                # upon import. Don't make CI flaky if ResourceWarning raised"}, {"line_no": 19, "char_start": 938, "char_end": 980, "line": "                # due to these open files."}, {"line_no": 20, "char_start": 981, "char_end": 1048, "line": "                if any(\"matplotlib\" in mod for mod in sys.modules):"}, {"line_no": 21, "char_start": 1049, "char_end": 1077, "line": "                    continue"}, {"line_no": 22, "char_start": 1078, "char_end": 1146, "line": "            if PY311 and actual_warning.category == EncodingWarning:"}, {"line_no": 23, "char_start": 1147, "char_end": 1203, "line": "                # EncodingWarnings are checked in the CI"}, {"line_no": 24, "char_start": 1204, "char_end": 1273, "line": "                # pyproject.toml errors on EncodingWarnings in pandas"}, {"line_no": 25, "char_start": 1274, "char_end": 1336, "line": "                # Ignore EncodingWarnings from other libraries"}, {"line_no": 26, "char_start": 1337, "char_end": 1361, "line": "                continue"}, {"line_no": 27, "char_start": 1362, "char_end": 1396, "line": "            extra_warnings.append("}, {"line_no": 28, "char_start": 1397, "char_end": 1414, "line": "                ("}, {"line_no": 29, "char_start": 1415, "char_end": 1468, "line": "                    actual_warning.category.__name__,"}, {"line_no": 30, "char_start": 1469, "char_end": 1512, "line": "                    actual_warning.message,"}, {"line_no": 31, "char_start": 1513, "char_end": 1557, "line": "                    actual_warning.filename,"}, {"line_no": 32, "char_start": 1558, "char_end": 1600, "line": "                    actual_warning.lineno,"}, {"line_no": 33, "char_start": 1601, "char_end": 1618, "line": "                )"}, {"line_no": 34, "char_start": 1619, "char_end": 1632, "line": "            )"}]}, "char_changes": {"deleted": [{"char_start": 4, "char_end": 186, "chars": "docs(ctx, sphinx_target, clean, first_build, jobs):\n    \"\"\"\ud83d\udcd6 Build Sphinx documentation\n\n    By default, SPHINXOPTS=\"-W\", raising errors on warnings.\n    To build without raising on "}, {"char_start": 193, "char_end": 194, "chars": "s"}, {"char_start": 196, "char_end": 513, "chars": "\n      SPHINXOPTS=\"\" spin docs\n\n    To list all Sphinx targets:\n\n      spin docs targets\n\n    To build another Sphinx target:\n\n      spin docs TARGET\n\n    E.g., to build a zipfile of the html docs for distribution:\n\n      spin docs dist\n\n    \"\"\"\n    meson.docs.ignore_unknown_options = True\n    ctx.forward(meson.docs"}], "added": [{"char_start": 4, "char_end": 330, "chars": "_assert_caught_no_extra_warnings(\n    *,\n    caught_warnings: Sequence[warnings.WarningMessage],\n    expected_warning: type[Warning] | bool | tuple[type[Warning], ...] | None,\n) -> None:\n    \"\"\"Assert that no extra warnings apart from the expected ones are caught.\"\"\"\n    extra_warnings = []\n\n    for actual_warning in caught_"}, {"char_start": 338, "char_end": 339, "chars": ":"}, {"char_start": 344, "char_end": 399, "chars": "    if _is_unexpected_warning(actual_warning, expected_"}, {"char_start": 406, "char_end": 407, "chars": ")"}, {"char_start": 415, "char_end": 1741, "chars": "      # GH#38630 pytest.filterwarnings does not suppress these.\n            if actual_warning.category == ResourceWarning:\n                # GH 44732: Don't make the CI flaky by filtering SSL-related\n                # ResourceWarning from dependencies\n                if \"unclosed <ssl.SSLSocket\" in str(actual_warning.message):\n                    continue\n                # GH 44844: Matplotlib leaves font files open during the entire process\n                # upon import. Don't make CI flaky if ResourceWarning raised\n                # due to these open files.\n                if any(\"matplotlib\" in mod for mod in sys.modules):\n                    continue\n            if PY311 and actual_warning.category == EncodingWarning:\n                # EncodingWarnings are checked in the CI\n                # pyproject.toml errors on EncodingWarnings in pandas\n                # Ignore EncodingWarnings from other libraries\n                continue\n            extra_warnings.append(\n                (\n                    actual_warning.category.__name__,\n                    actual_warning.message,\n                    actual_warning.filename,\n                    actual_warning.lineno,\n                )\n            )\n\n    if extra_warnings:\n        raise AssertionError(f\"Caused unexpected warning(s): {repr(extra_warnings)}\""}]}}
{"func_name": "test", "func_src_before": "def test(ctx, pytest_args, markexpr, n_jobs, tests, verbose):\n    \"\"\"\ud83d\udd27 Run tests\n\n    PYTEST_ARGS are passed through directly to pytest, e.g.:\n\n      spin test -- --pdb\n\n    To run tests on a directory or file:\n\n     \\b\n     spin test numpy/linalg\n     spin test numpy/linalg/tests/test_linalg.py\n\n    To report the durations of the N slowest tests:\n\n      spin test -- --durations=N\n\n    To run tests that match a given pattern:\n\n     \\b\n     spin test -- -k \"geometric\"\n     spin test -- -k \"geometric and not rgeometric\"\n\n    By default, spin will run `-m 'not slow'`. To run the full test suite, use\n    `spin -m full`\n\n    For more, see `pytest --help`.\n    \"\"\"  # noqa: E501\n    if (not pytest_args) and (not tests):\n        pytest_args = ('numpy',)\n\n    if '-m' not in pytest_args:\n        if markexpr != \"full\":\n            pytest_args = ('-m', markexpr) + pytest_args\n\n    if (n_jobs != \"1\") and ('-n' not in pytest_args):\n        pytest_args = ('-n', str(n_jobs)) + pytest_args\n\n    if tests and not ('--pyargs' in pytest_args):\n        pytest_args = ('--pyargs', tests) + pytest_args\n\n    if verbose:\n        pytest_args = ('-v',) + pytest_args\n\n    ctx.params['pytest_args'] = pytest_args\n\n    for extra_param in ('markexpr', 'n_jobs', 'tests', 'verbose'):\n        del ctx.params[extra_param]\n    ctx.forward(meson.test)", "func_src_after": "def _is_unexpected_warning(\n    actual_warning: warnings.WarningMessage,\n    expected_warning: type[Warning] | bool | tuple[type[Warning], ...] | None,\n) -> bool:\n    \"\"\"Check if the actual warning issued is unexpected.\"\"\"\n    if actual_warning and not expected_warning:\n        return True\n    expected_warning = cast(type[Warning], expected_warning)\n    return bool(not issubclass(actual_warning.category, expected_warning))", "line_changes": {"deleted": [{"line_no": 2, "char_start": 62, "char_end": 80, "line": "    \"\"\"\ud83d\udd27 Run tests"}, {"line_no": 30, "char_start": 723, "char_end": 755, "line": "        pytest_args = ('numpy',)"}], "added": [{"line_no": 2, "char_start": 28, "char_end": 72, "line": "    actual_warning: warnings.WarningMessage,"}, {"line_no": 3, "char_start": 73, "char_end": 151, "line": "    expected_warning: type[Warning] | bool | tuple[type[Warning], ...] | None,"}, {"line_no": 4, "char_start": 152, "char_end": 162, "line": ") -> bool:"}, {"line_no": 5, "char_start": 163, "char_end": 222, "line": "    \"\"\"Check if the actual warning issued is unexpected.\"\"\""}, {"line_no": 7, "char_start": 271, "char_end": 290, "line": "        return True"}, {"line_no": 8, "char_start": 291, "char_end": 351, "line": "    expected_warning = cast(type[Warning], expected_warning)"}, {"line_no": 9, "char_start": 352, "char_end": 426, "line": "    return bool(not issubclass(actual_warning.category, expected_warning))"}]}, "char_changes": {"deleted": [{"char_start": 4, "char_end": 705, "chars": "test(ctx, pytest_args, markexpr, n_jobs, tests, verbose):\n    \"\"\"\ud83d\udd27 Run tests\n\n    PYTEST_ARGS are passed through directly to pytest, e.g.:\n\n      spin test -- --pdb\n\n    To run tests on a directory or file:\n\n     \\b\n     spin test numpy/linalg\n     spin test numpy/linalg/tests/test_linalg.py\n\n    To report the durations of the N slowest tests:\n\n      spin test -- --durations=N\n\n    To run tests that match a given pattern:\n\n     \\b\n     spin test -- -k \"geometric\"\n     spin test -- -k \"geometric and not rgeometric\"\n\n    By default, spin will run `-m 'not slow'`. To run the full test suite, use\n    `spin -m full`\n\n    For more, see `pytest --help`.\n    \"\"\"  # noqa: E501\n    if (not pytest_args)"}, {"char_start": 710, "char_end": 711, "chars": "("}, {"char_start": 715, "char_end": 1331, "chars": "tests):\n        pytest_args = ('numpy',)\n\n    if '-m' not in pytest_args:\n        if markexpr != \"full\":\n            pytest_args = ('-m', markexpr) + pytest_args\n\n    if (n_jobs != \"1\") and ('-n' not in pytest_args):\n        pytest_args = ('-n', str(n_jobs)) + pytest_args\n\n    if tests and not ('--pyargs' in pytest_args):\n        pytest_args = ('--pyargs', tests) + pytest_args\n\n    if verbose:\n        pytest_args = ('-v',) + pytest_args\n\n    ctx.params['pytest_args'] = pytest_args\n\n    for extra_param in ('markexpr', 'n_jobs', 'tests', 'verbose'):\n        del ctx.params[extra_param]\n    ctx.forward(meson.test"}], "added": [{"char_start": 4, "char_end": 244, "chars": "_is_unexpected_warning(\n    actual_warning: warnings.WarningMessage,\n    expected_warning: type[Warning] | bool | tuple[type[Warning], ...] | None,\n) -> bool:\n    \"\"\"Check if the actual warning issued is unexpected.\"\"\"\n    if actual_warning"}, {"char_start": 253, "char_end": 425, "chars": "expected_warning:\n        return True\n    expected_warning = cast(type[Warning], expected_warning)\n    return bool(not issubclass(actual_warning.category, expected_warning)"}]}}
{"func_name": "_set_mem_rlimit", "func_src_before": "def _set_mem_rlimit(max_mem=None):\n    \"\"\"\n    Set address space rlimit\n    \"\"\"\n    import resource\n    import psutil\n\n    mem = psutil.virtual_memory()\n\n    if max_mem is None:\n        max_mem = int(mem.total * 0.7)\n    cur_limit = resource.getrlimit(resource.RLIMIT_AS)\n    if cur_limit[0] > 0:\n        max_mem = min(max_mem, cur_limit[0])\n\n    try:\n        resource.setrlimit(resource.RLIMIT_AS, (max_mem, cur_limit[1]))\n    except ValueError:\n        # on macOS may raise: current limit exceeds maximum limit\n        pass", "func_src_after": "def _assert_raised_with_correct_stacklevel(\n    actual_warning: warnings.WarningMessage,\n) -> None:\n    # https://stackoverflow.com/questions/17407119/python-inspect-stack-is-slow\n    frame = inspect.currentframe()\n    for _ in range(4):\n        frame = frame.f_back  # type: ignore[union-attr]\n    caller_filename = inspect.getfile(frame)  # type: ignore[arg-type]\n    msg = (\n        \"Warning not set with correct stacklevel. \"\n        f\"File where warning is raised: {actual_warning.filename} != \"\n        f\"{caller_filename}. Warning message: {actual_warning.message}\"\n    )\n    assert actual_warning.filename == caller_filename, msg", "line_changes": {"deleted": [{"line_no": 2, "char_start": 35, "char_end": 42, "line": "    \"\"\""}, {"line_no": 3, "char_start": 43, "char_end": 71, "line": "    Set address space rlimit"}, {"line_no": 4, "char_start": 72, "char_end": 79, "line": "    \"\"\""}, {"line_no": 5, "char_start": 80, "char_end": 99, "line": "    import resource"}, {"line_no": 6, "char_start": 100, "char_end": 117, "line": "    import psutil"}, {"line_no": 9, "char_start": 153, "char_end": 153, "line": ""}, {"line_no": 10, "char_start": 154, "char_end": 177, "line": "    if max_mem is None:"}, {"line_no": 12, "char_start": 217, "char_end": 271, "line": "    cur_limit = resource.getrlimit(resource.RLIMIT_AS)"}, {"line_no": 13, "char_start": 272, "char_end": 296, "line": "    if cur_limit[0] > 0:"}, {"line_no": 14, "char_start": 297, "char_end": 341, "line": "        max_mem = min(max_mem, cur_limit[0])"}], "added": [{"line_no": 2, "char_start": 44, "char_end": 88, "line": "    actual_warning: warnings.WarningMessage,"}, {"line_no": 3, "char_start": 89, "char_end": 99, "line": ") -> None:"}, {"line_no": 4, "char_start": 100, "char_end": 179, "line": "    # https://stackoverflow.com/questions/17407119/python-inspect-stack-is-slow"}, {"line_no": 6, "char_start": 215, "char_end": 237, "line": "    for _ in range(4):"}, {"line_no": 8, "char_start": 295, "char_end": 365, "line": "    caller_filename = inspect.getfile(frame)  # type: ignore[arg-type]"}, {"line_no": 9, "char_start": 366, "char_end": 377, "line": "    msg = ("}, {"line_no": 10, "char_start": 378, "char_end": 429, "line": "        \"Warning not set with correct stacklevel. \""}, {"line_no": 11, "char_start": 430, "char_end": 500, "line": "        f\"File where warning is raised: {actual_warning.filename} != \""}, {"line_no": 12, "char_start": 501, "char_end": 572, "line": "        f\"{caller_filename}. Warning message: {actual_warning.message}\""}, {"line_no": 13, "char_start": 573, "char_end": 578, "line": "    )"}]}, "char_changes": {"deleted": [{"char_start": 9, "char_end": 118, "chars": "mem_rlimit(max_mem=None):\n    \"\"\"\n    Set address space rlimit\n    \"\"\"\n    import resource\n    import psutil\n"}, {"char_start": 125, "char_end": 126, "chars": "m"}, {"char_start": 129, "char_end": 150, "chars": "psutil.virtual_memory"}, {"char_start": 153, "char_end": 154, "chars": "\n"}, {"char_start": 158, "char_end": 176, "chars": "if max_mem is None"}, {"char_start": 186, "char_end": 190, "chars": "max_"}, {"char_start": 192, "char_end": 193, "chars": "m"}, {"char_start": 196, "char_end": 512, "chars": "int(mem.total * 0.7)\n    cur_limit = resource.getrlimit(resource.RLIMIT_AS)\n    if cur_limit[0] > 0:\n        max_mem = min(max_mem, cur_limit[0])\n\n    try:\n        resource.setrlimit(resource.RLIMIT_AS, (max_mem, cur_limit[1]))\n    except ValueError:\n        # on macOS may raise: current limit exceeds maximum limit"}, {"char_start": 521, "char_end": 522, "chars": "p"}], "added": [{"char_start": 5, "char_end": 7, "chars": "as"}, {"char_start": 9, "char_end": 10, "chars": "r"}, {"char_start": 12, "char_end": 179, "chars": "raised_with_correct_stacklevel(\n    actual_warning: warnings.WarningMessage,\n) -> None:\n    # https://stackoverflow.com/questions/17407119/python-inspect-stack-is-slow"}, {"char_start": 184, "char_end": 187, "chars": "fra"}, {"char_start": 192, "char_end": 212, "chars": "inspect.currentframe"}, {"char_start": 219, "char_end": 236, "chars": "for _ in range(4)"}, {"char_start": 246, "char_end": 249, "chars": "fra"}, {"char_start": 254, "char_end": 572, "chars": "frame.f_back  # type: ignore[union-attr]\n    caller_filename = inspect.getfile(frame)  # type: ignore[arg-type]\n    msg = (\n        \"Warning not set with correct stacklevel. \"\n        f\"File where warning is raised: {actual_warning.filename} != \"\n        f\"{caller_filename}. Warning message: {actual_warning.message}\""}, {"char_start": 577, "char_end": 579, "chars": ")\n"}, {"char_start": 586, "char_end": 637, "chars": "ert actual_warning.filename == caller_filename, msg"}]}}
{"func_name": "_commit_to_sha", "func_src_before": "def _commit_to_sha(commit):\n    p = util.run(['git', 'rev-parse', commit], output=False, echo=False)\n    if p.returncode != 0:\n        raise(\n            click.ClickException(\n                f'Could not find SHA matching commit `{commit}`'\n            )\n        )\n\n    return p.stdout.decode('ascii').strip()", "func_src_after": "    def setTZ(tz) -> None:\n        if tz is None:\n            try:\n                del os.environ[\"TZ\"]\n            except KeyError:\n                pass\n        else:\n            os.environ[\"TZ\"] = tz\n            time.tzset()", "line_changes": {"deleted": [{"line_no": 1, "char_start": 1, "char_end": 28, "line": "def _commit_to_sha(commit):"}, {"line_no": 2, "char_start": 28, "char_end": 100, "line": "    p = util.run(['git', 'rev-parse', commit], output=False, echo=False)"}, {"line_no": 3, "char_start": 101, "char_end": 126, "line": "    if p.returncode != 0:"}, {"line_no": 4, "char_start": 127, "char_end": 141, "line": "        raise("}, {"line_no": 5, "char_start": 142, "char_end": 175, "line": "            click.ClickException("}, {"line_no": 6, "char_start": 176, "char_end": 240, "line": "                f'Could not find SHA matching commit `{commit}`'"}, {"line_no": 7, "char_start": 241, "char_end": 254, "line": "            )"}, {"line_no": 8, "char_start": 255, "char_end": 264, "line": "        )"}, {"line_no": 9, "char_start": 265, "char_end": 265, "line": ""}], "added": [{"line_no": 1, "char_start": 1, "char_end": 27, "line": "    def setTZ(tz) -> None:"}, {"line_no": 2, "char_start": 27, "char_end": 49, "line": "        if tz is None:"}, {"line_no": 3, "char_start": 50, "char_end": 66, "line": "            try:"}, {"line_no": 4, "char_start": 67, "char_end": 103, "line": "                del os.environ[\"TZ\"]"}, {"line_no": 5, "char_start": 104, "char_end": 132, "line": "            except KeyError:"}, {"line_no": 6, "char_start": 133, "char_end": 153, "line": "                pass"}, {"line_no": 7, "char_start": 154, "char_end": 167, "line": "        else:"}, {"line_no": 8, "char_start": 168, "char_end": 201, "line": "            os.environ[\"TZ\"] = tz"}]}, "char_changes": {"deleted": [{"char_start": 0, "char_end": 254, "chars": "def _commit_to_sha(commit):\n    p = util.run(['git', 'rev-parse', commit], output=False, echo=False)\n    if p.returncode != 0:\n        raise(\n            click.ClickException(\n                f'Could not find SHA matching commit `{commit}`'\n            )"}, {"char_start": 263, "char_end": 266, "chars": ")\n\n"}, {"char_start": 270, "char_end": 307, "chars": "return p.stdout.decode('ascii').strip"}], "added": [{"char_start": 0, "char_end": 202, "chars": "    def setTZ(tz) -> None:\n        if tz is None:\n            try:\n                del os.environ[\"TZ\"]\n            except KeyError:\n                pass\n        else:\n            os.environ[\"TZ\"] = tz\n"}, {"char_start": 212, "char_end": 224, "chars": "  time.tzset"}]}}
{"func_name": "_dirty_git_working_dir", "func_src_before": "def _dirty_git_working_dir():\n    # Changes to the working directory\n    p0 = util.run(['git', 'diff-files', '--quiet'])\n\n    # Staged changes\n    p1 = util.run(['git', 'diff-index', '--quiet', '--cached', 'HEAD'])\n\n    return (p0.returncode != 0 or p1.returncode != 0)", "func_src_after": "def decompress_file(\n    path: FilePath | BaseBuffer, compression: CompressionOptions\n) -> Generator[IO[bytes], None, None]:\n    \"\"\"\n    Open a compressed file and return a file object.\n\n    Parameters\n    ----------\n    path : str\n        The path where the file is read from.\n\n    compression : {'gzip', 'bz2', 'zip', 'xz', 'zstd', None}\n        Name of the decompression to use\n\n    Returns\n    -------\n    file object\n    \"\"\"\n    with get_handle(path, \"rb\", compression=compression, is_text=False) as handle:\n        yield handle.handle\n\n    def setTZ(tz) -> None:\n        if tz is None:\n            try:\n                del os.environ[\"TZ\"]\n            except KeyError:\n                pass\n        else:\n            os.environ[\"TZ\"] = tz\n            time.tzset()", "line_changes": {"deleted": [{"line_no": 2, "char_start": 30, "char_end": 68, "line": "    # Changes to the working directory"}, {"line_no": 3, "char_start": 69, "char_end": 120, "line": "    p0 = util.run(['git', 'diff-files', '--quiet'])"}], "added": [{"line_no": 2, "char_start": 21, "char_end": 85, "line": "    path: FilePath | BaseBuffer, compression: CompressionOptions"}, {"line_no": 3, "char_start": 86, "char_end": 124, "line": ") -> Generator[IO[bytes], None, None]:"}, {"line_no": 4, "char_start": 125, "char_end": 132, "line": "    \"\"\""}, {"line_no": 5, "char_start": 133, "char_end": 185, "line": "    Open a compressed file and return a file object."}, {"line_no": 16, "char_start": 394, "char_end": 405, "line": "    -------"}, {"line_no": 17, "char_start": 406, "char_end": 421, "line": "    file object"}, {"line_no": 18, "char_start": 422, "char_end": 429, "line": "    \"\"\""}, {"line_no": 19, "char_start": 430, "char_end": 512, "line": "    with get_handle(path, \"rb\", compression=compression, is_text=False) as handle:"}, {"line_no": 20, "char_start": 513, "char_end": 540, "line": "        yield handle.handle"}]}, "char_changes": {"deleted": [{"char_start": 4, "char_end": 214, "chars": "_dirty_git_working_dir():\n    # Changes to the working directory\n    p0 = util.run(['git', 'diff-files', '--quiet'])\n\n    # Staged changes\n    p1 = util.run(['git', 'diff-index', '--quiet', '--cached', 'HEAD'])"}, {"char_start": 220, "char_end": 221, "chars": "r"}, {"char_start": 226, "char_end": 268, "chars": " (p0.returncode != 0 or p1.returncode != 0"}], "added": [{"char_start": 4, "char_end": 380, "chars": "decompress_file(\n    path: FilePath | BaseBuffer, compression: CompressionOptions\n) -> Generator[IO[bytes], None, None]:\n    \"\"\"\n    Open a compressed file and return a file object.\n\n    Parameters\n    ----------\n    path : str\n        The path where the file is read from.\n\n    compression : {'gzip', 'bz2', 'zip', 'xz', 'zstd', None}\n        Name of the decompression to use"}, {"char_start": 386, "char_end": 387, "chars": "R"}, {"char_start": 392, "char_end": 767, "chars": "s\n    -------\n    file object\n    \"\"\"\n    with get_handle(path, \"rb\", compression=compression, is_text=False) as handle:\n        yield handle.handle\n\n    def setTZ(tz) -> None:\n        if tz is None:\n            try:\n                del os.environ[\"TZ\"]\n            except KeyError:\n                pass\n        else:\n            os.environ[\"TZ\"] = tz\n            time.tzset("}]}}
{"func_name": "_run_asv", "func_src_before": "def _run_asv(cmd):\n    # Always use ccache, if installed\n    PATH = os.environ['PATH']\n    EXTRA_PATH = os.pathsep.join([\n        '/usr/lib/ccache', '/usr/lib/f90cache',\n        '/usr/local/lib/ccache', '/usr/local/lib/f90cache'\n    ])\n    env = os.environ\n    env['PATH'] = f'EXTRA_PATH:{PATH}'\n\n    # Control BLAS/LAPACK threads\n    env['OPENBLAS_NUM_THREADS'] = '1'\n    env['MKL_NUM_THREADS'] = '1'\n\n    # Limit memory usage\n    try:\n        _set_mem_rlimit()\n    except (ImportError, RuntimeError):\n        pass\n\n    util.run(cmd, cwd='benchmarks', env=env)", "func_src_after": "    def setTZ(tz) -> None:\n        if tz is None:\n            try:\n                del os.environ[\"TZ\"]\n            except KeyError:\n                pass\n        else:\n            os.environ[\"TZ\"] = tz\n            time.tzset()", "line_changes": {"deleted": [{"line_no": 1, "char_start": 1, "char_end": 19, "line": "def _run_asv(cmd):"}, {"line_no": 2, "char_start": 19, "char_end": 56, "line": "    # Always use ccache, if installed"}, {"line_no": 3, "char_start": 57, "char_end": 86, "line": "    PATH = os.environ['PATH']"}, {"line_no": 4, "char_start": 87, "char_end": 121, "line": "    EXTRA_PATH = os.pathsep.join(["}, {"line_no": 5, "char_start": 122, "char_end": 169, "line": "        '/usr/lib/ccache', '/usr/lib/f90cache',"}, {"line_no": 6, "char_start": 170, "char_end": 228, "line": "        '/usr/local/lib/ccache', '/usr/local/lib/f90cache'"}, {"line_no": 7, "char_start": 229, "char_end": 235, "line": "    ])"}, {"line_no": 8, "char_start": 236, "char_end": 256, "line": "    env = os.environ"}, {"line_no": 9, "char_start": 257, "char_end": 295, "line": "    env['PATH'] = f'EXTRA_PATH:{PATH}'"}, {"line_no": 19, "char_start": 503, "char_end": 515, "line": "        pass"}, {"line_no": 20, "char_start": 516, "char_end": 516, "line": ""}], "added": [{"line_no": 1, "char_start": 1, "char_end": 27, "line": "    def setTZ(tz) -> None:"}, {"line_no": 2, "char_start": 27, "char_end": 49, "line": "        if tz is None:"}, {"line_no": 3, "char_start": 50, "char_end": 66, "line": "            try:"}, {"line_no": 4, "char_start": 67, "char_end": 103, "line": "                del os.environ[\"TZ\"]"}, {"line_no": 5, "char_start": 104, "char_end": 132, "line": "            except KeyError:"}, {"line_no": 6, "char_start": 133, "char_end": 153, "line": "                pass"}, {"line_no": 7, "char_start": 154, "char_end": 167, "line": "        else:"}, {"line_no": 8, "char_start": 168, "char_end": 201, "line": "            os.environ[\"TZ\"] = tz"}]}, "char_changes": {"deleted": [{"char_start": 0, "char_end": 502, "chars": "def _run_asv(cmd):\n    # Always use ccache, if installed\n    PATH = os.environ['PATH']\n    EXTRA_PATH = os.pathsep.join([\n        '/usr/lib/ccache', '/usr/lib/f90cache',\n        '/usr/local/lib/ccache', '/usr/local/lib/f90cache'\n    ])\n    env = os.environ\n    env['PATH'] = f'EXTRA_PATH:{PATH}'\n\n    # Control BLAS/LAPACK threads\n    env['OPENBLAS_NUM_THREADS'] = '1'\n    env['MKL_NUM_THREADS'] = '1'\n\n    # Limit memory usage\n    try:\n        _set_mem_rlimit()\n    except (ImportError, RuntimeError):"}, {"char_start": 511, "char_end": 517, "chars": "pass\n\n"}, {"char_start": 521, "char_end": 522, "chars": "u"}, {"char_start": 524, "char_end": 560, "chars": "l.run(cmd, cwd='benchmarks', env=env"}], "added": [{"char_start": 0, "char_end": 201, "chars": "    def setTZ(tz) -> None:\n        if tz is None:\n            try:\n                del os.environ[\"TZ\"]\n            except KeyError:\n                pass\n        else:\n            os.environ[\"TZ\"] = tz"}, {"char_start": 216, "char_end": 225, "chars": "me.tzset("}]}}
{"func_name": "lint", "func_src_before": "def lint(ctx, branch, uncommitted):\n    \"\"\"\ud83d\udd26 Run lint checks on diffs.\n    Provide target branch name or `uncommitted` to check changes before committing:\n\n    \\b\n    Examples:\n\n    \\b\n    For lint checks of your development brach with `main` or a custom branch:\n\n    \\b\n    $ spin lint # defaults to main\n    $ spin lint --branch custom_branch\n\n    \\b\n    To check just the uncommitted changes before committing\n\n    \\b\n    $ spin lint --uncommitted\n    \"\"\"\n    try:\n        linter = _get_numpy_tools(pathlib.Path('linter.py'))\n    except ModuleNotFoundError as e:\n        raise click.ClickException(\n            f\"{e.msg}. Install using linter_requirements.txt\"\n        )\n\n    linter.DiffLinter(branch).run_lint(uncommitted)", "func_src_after": "def set_timezone(tz: str) -> Generator[None, None, None]:\n    \"\"\"\n    Context manager for temporarily setting a timezone.\n\n    Parameters\n    ----------\n    tz : str\n        A string representing a valid timezone.\n\n    Examples\n    --------\n    >>> from datetime import datetime\n    >>> from dateutil.tz import tzlocal\n    >>> tzlocal().tzname(datetime(2021, 1, 1))  # doctest: +SKIP\n    'IST'\n\n    >>> with set_timezone('US/Eastern'):\n    ...     tzlocal().tzname(datetime(2021, 1, 1))\n    ...\n    'EST'\n    \"\"\"\n    import time\n\n    def setTZ(tz) -> None:\n        if tz is None:\n            try:\n                del os.environ[\"TZ\"]\n            except KeyError:\n                pass\n        else:\n            os.environ[\"TZ\"] = tz\n            time.tzset()\n\n    orig_tz = os.environ.get(\"TZ\")\n    setTZ(tz)\n    try:\n        yield\n    finally:\n        setTZ(orig_tz)", "line_changes": {"deleted": [{"line_no": 2, "char_start": 36, "char_end": 70, "line": "    \"\"\"\ud83d\udd26 Run lint checks on diffs."}, {"line_no": 3, "char_start": 71, "char_end": 154, "line": "    Provide target branch name or `uncommitted` to check changes before committing:"}, {"line_no": 8, "char_start": 178, "char_end": 184, "line": "    \\b"}, {"line_no": 9, "char_start": 185, "char_end": 262, "line": "    For lint checks of your development brach with `main` or a custom branch:"}, {"line_no": 18, "char_start": 414, "char_end": 420, "line": "    \\b"}, {"line_no": 19, "char_start": 421, "char_end": 450, "line": "    $ spin lint --uncommitted"}, {"line_no": 20, "char_start": 451, "char_end": 458, "line": "    \"\"\""}, {"line_no": 22, "char_start": 468, "char_end": 528, "line": "        linter = _get_numpy_tools(pathlib.Path('linter.py'))"}, {"line_no": 23, "char_start": 529, "char_end": 565, "line": "    except ModuleNotFoundError as e:"}, {"line_no": 24, "char_start": 566, "char_end": 601, "line": "        raise click.ClickException("}, {"line_no": 25, "char_start": 602, "char_end": 663, "line": "            f\"{e.msg}. Install using linter_requirements.txt\""}, {"line_no": 26, "char_start": 664, "char_end": 673, "line": "        )"}, {"line_no": 27, "char_start": 674, "char_end": 674, "line": ""}, {"line_no": 28, "char_start": 675, "char_end": 726, "line": "    linter.DiffLinter(branch).run_lint(uncommitted)"}], "added": [{"line_no": 2, "char_start": 58, "char_end": 65, "line": "    \"\"\""}, {"line_no": 3, "char_start": 66, "char_end": 121, "line": "    Context manager for temporarily setting a timezone."}, {"line_no": 11, "char_start": 228, "char_end": 240, "line": "    --------"}, {"line_no": 12, "char_start": 241, "char_end": 278, "line": "    >>> from datetime import datetime"}, {"line_no": 13, "char_start": 279, "char_end": 318, "line": "    >>> from dateutil.tz import tzlocal"}, {"line_no": 14, "char_start": 319, "char_end": 383, "line": "    >>> tzlocal().tzname(datetime(2021, 1, 1))  # doctest: +SKIP"}, {"line_no": 15, "char_start": 384, "char_end": 393, "line": "    'IST'"}, {"line_no": 19, "char_start": 487, "char_end": 494, "line": "    ..."}, {"line_no": 20, "char_start": 495, "char_end": 504, "line": "    'EST'"}, {"line_no": 21, "char_start": 505, "char_end": 512, "line": "    \"\"\""}, {"line_no": 22, "char_start": 513, "char_end": 528, "line": "    import time"}, {"line_no": 25, "char_start": 557, "char_end": 579, "line": "        if tz is None:"}, {"line_no": 27, "char_start": 597, "char_end": 633, "line": "                del os.environ[\"TZ\"]"}, {"line_no": 28, "char_start": 634, "char_end": 662, "line": "            except KeyError:"}, {"line_no": 29, "char_start": 663, "char_end": 683, "line": "                pass"}, {"line_no": 30, "char_start": 684, "char_end": 697, "line": "        else:"}, {"line_no": 31, "char_start": 698, "char_end": 731, "line": "            os.environ[\"TZ\"] = tz"}, {"line_no": 32, "char_start": 732, "char_end": 756, "line": "            time.tzset()"}]}, "char_changes": {"deleted": [{"char_start": 4, "char_end": 162, "chars": "lint(ctx, branch, uncommitted):\n    \"\"\"\ud83d\udd26 Run lint checks on diffs.\n    Provide target branch name or `uncommitted` to check changes before committing:\n\n    \\b"}, {"char_start": 175, "char_end": 177, "chars": ":\n"}, {"char_start": 182, "char_end": 413, "chars": "\\b\n    For lint checks of your development brach with `main` or a custom branch:\n\n    \\b\n    $ spin lint # defaults to main\n    $ spin lint --branch custom_branch\n\n    \\b\n    To check just the uncommitted changes before committing\n"}, {"char_start": 418, "char_end": 421, "chars": "\\b\n"}, {"char_start": 425, "char_end": 450, "chars": "$ spin lint --uncommitted"}, {"char_start": 455, "char_end": 459, "chars": "\"\"\"\n"}, {"char_start": 476, "char_end": 668, "chars": "linter = _get_numpy_tools(pathlib.Path('linter.py'))\n    except ModuleNotFoundError as e:\n        raise click.ClickException(\n            f\"{e.msg}. Install using linter_requirements.txt\"\n    "}, {"char_start": 672, "char_end": 675, "chars": ")\n\n"}, {"char_start": 679, "char_end": 725, "chars": "linter.DiffLinter(branch).run_lint(uncommitted"}], "added": [{"char_start": 4, "char_end": 214, "chars": "set_timezone(tz: str) -> Generator[None, None, None]:\n    \"\"\"\n    Context manager for temporarily setting a timezone.\n\n    Parameters\n    ----------\n    tz : str\n        A string representing a valid timezone.\n"}, {"char_start": 232, "char_end": 486, "chars": "--------\n    >>> from datetime import datetime\n    >>> from dateutil.tz import tzlocal\n    >>> tzlocal().tzname(datetime(2021, 1, 1))  # doctest: +SKIP\n    'IST'\n\n    >>> with set_timezone('US/Eastern'):\n    ...     tzlocal().tzname(datetime(2021, 1, 1))"}, {"char_start": 491, "char_end": 494, "chars": "..."}, {"char_start": 499, "char_end": 556, "chars": "'EST'\n    \"\"\"\n    import time\n\n    def setTZ(tz) -> None:"}, {"char_start": 565, "char_end": 579, "chars": "if tz is None:"}, {"char_start": 584, "char_end": 585, "chars": " "}, {"char_start": 589, "char_end": 592, "chars": "   "}, {"char_start": 605, "char_end": 864, "chars": "        del os.environ[\"TZ\"]\n            except KeyError:\n                pass\n        else:\n            os.environ[\"TZ\"] = tz\n            time.tzset()\n\n    orig_tz = os.environ.get(\"TZ\")\n    setTZ(tz)\n    try:\n        yield\n    finally:\n        setTZ(orig_tz"}]}}
